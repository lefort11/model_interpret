#include "Parser.h"void Parser::Analyze(){	GetLexeme();	if(currentLexeme == LEXEME_PROGRAM)	{		GetLexeme();		Program();		if (currentLexeme != LEXEME_END)			throw ParserException();	}	else throw ParserException();}void Parser::Program(){	if (currentLexeme == LEXEME_LPARENTH)	{		GetLexeme();		Descriptions();		Operators();		if (currentLexeme != LEXEME_RPARENTH)			throw ParserException();		GetLexeme();	}	else		throw ParserException();}void Parser::Descriptions(){	while (currentLexeme == LEXEME_STRUCT)	{		StructDescription(); //currentLexeme == LEXEME_SEMICOLON ???	}	while ((currentLexeme == LEXEME_INT) || (currentLexeme == LEXEME_REAL) || (currentLexeme == LEXEME_STRING) || ((currentLexeme.GetType() == LEXEME_NAME) && (scanner.identTable[currentLexeme.GetValue()].GetType() == STRUCT_NAME)))	{		VariableDescription();	}}void Parser::StructDescription(){	/* В таблице лексем значение лексемы-имени структуры - номер в таблице всех имен		В таблице всех имен значение имени - номер в таблице структур, которая представляет собой вектор таблиц идентификаторов		Каждое имя члена структуры вносится в соотетсвующую таблицу идентификаторов	*/	//currentLexeme == LEXEME_STRUCT	GetLexeme();	if (currentLexeme.GetType() == LEXEME_NAME)	{		scanner.identTable[currentLexeme.GetValue()].ChangeType(STRUCT_NAME);		scanner.identTable[currentLexeme.GetType()].Declare();		scanner.identTable[currentLexeme.GetValue()].ChangeIntValue(lastStructureNumber);		structuresVector.push_back(IdentTable());		//std::vector<IdentTable>::iterator it = --structures.end(); // iterator pointing at the last structure		GetLexeme();		if(currentLexeme == LEXEME_LPARENTH)		{			GetLexeme();			if ((currentLexeme == LEXEME_INT) || (currentLexeme == LEXEME_REAL) || (currentLexeme == LEXEME_STRING))			{				StructureMemberDescription(); //??				GetLexeme();			}			else				throw ParserException();			while ((currentLexeme == LEXEME_INT) || (currentLexeme == LEXEME_REAL) || (currentLexeme == LEXEME_STRING))			{				StructureMemberDescription(); // ??				GetLexeme();			}			if(currentLexeme == LEXEME_RPARENTH)			{				GetLexeme();				if (currentLexeme == LEXEME_SEMICOLON)					GetLexeme();				else					throw ParserException();			}			else throw ParserException();		}		++lastStructureNumber;	}	else		throw ParserException();}void Parser::VariableDescription(){	auto lexemeType = currentLexeme.GetType(); // saving current type of variable	GetLexeme();	if (currentLexeme.GetType() != LEXEME_NAME)		throw ParserException();	while ((currentLexeme.GetType() == LEXEME_NAME))	{		auto value = currentLexeme.GetValue();		if (scanner.identTable[value].IsDeclared())			throw ParserException();		scanner.identTable[value].Declare(); //making identifier declared		switch (lexemeType)		{			case LEXEME_INT:				scanner.identTable[value].ChangeType(INT);				break;			case LEXEME_REAL:				scanner.identTable[value].ChangeType(REAL);				break;			case LEXEME_STRING:				scanner.identTable[value].ChangeType(STRING);				break;			case LEXEME_NAME:				scanner.identTable[value].ChangeType(USER);				break;			default:				throw ParserException();		} //defining type		GetLexeme();				if (currentLexeme == LEXEME_ASSIGNMENT)		{			GetLexeme();			switch (lexemeType)			{				case LEXEME_INT:				{					bool unaryMinusFound = false;					if (currentLexeme == LEXEME_PLUS)						GetLexeme();					else if (currentLexeme == LEXEME_MINUS)					{						GetLexeme();						unaryMinusFound = true;					}					if (currentLexeme.GetType() != LEXEME_INT_CONST)						throw ParserException();					if(!unaryMinusFound)						scanner.identTable[value].ChangeIntValue(scanner.identTable[currentLexeme.GetValue()].GetIntValue());					else						scanner.identTable[value].ChangeIntValue(-scanner.identTable[currentLexeme.GetValue()].GetIntValue());					break;				}				case LEXEME_REAL:				{					bool unaryMinusFound = false;					if (currentLexeme == LEXEME_PLUS)						GetLexeme();					else if (currentLexeme == LEXEME_MINUS)					{						GetLexeme();						unaryMinusFound = true;					}					if (currentLexeme.GetType() != LEXEME_REAL_CONST)						throw ParserException();					if (!unaryMinusFound)						scanner.identTable[value].ChangeRealValue(scanner.identTable[currentLexeme.GetValue()].GetRealValue());					else						scanner.identTable[value].ChangeRealValue(-scanner.identTable[currentLexeme.GetValue()].GetRealValue());					break;				}				case LEXEME_STRING:				{					if (currentLexeme.GetType() != LEXEME_STRING_CONST)						throw ParserException();					scanner.identTable[value].ChangeStringValue(scanner.identTable[currentLexeme.GetValue()].GetStringValue());					break;				}				default:					throw ParserException();			}			GetLexeme();		}		// comma or semicolon after that		if (currentLexeme == LEXEME_COMMA)		{			GetLexeme();			if (currentLexeme.GetType() != LEXEME_NAME) // if there is no name after comma -> error				throw ParserException();		}	}	if (currentLexeme != LEXEME_SEMICOLON)		throw ParserException();	GetLexeme();}void Parser::Operators(){	while(currentLexeme != LEXEME_RPARENTH)	{		SingleOperator();	}}void Parser::SingleOperator(){	auto lexemeType = currentLexeme.GetType();	switch(lexemeType)	{		case LEXEME_IF:		{			GetLexeme();			if(currentLexeme.GetType() == LEXEME_LBRACKET)			{				GetLexeme();				Expression();				//currentLexeme == RBRACKET				if (currentLexeme.GetType() != LEXEME_RBRACKET)					throw ParserException();				GetLexeme();				SingleOperator();				if (currentLexeme.GetType() != LEXEME_ELSE)					throw ParserException();				GetLexeme();				SingleOperator();			}			else				throw ParserException();			break;		}		case LEXEME_WHILE:		{			++isLoop;			GetLexeme();			if(currentLexeme.GetType() == LEXEME_LBRACKET)			{				GetLexeme();				Expression();				if (currentLexeme.GetType() != LEXEME_RBRACKET)					throw ParserException();				GetLexeme();				SingleOperator();			}			else throw ParserException();			--isLoop;			break;		}		case LEXEME_FOR:		{			GetLexeme();			++isLoop;			if(currentLexeme.GetType() == LEXEME_LBRACKET)			{				for(int i = 0; i < 2; ++i)				{					GetLexeme();					if (currentLexeme.GetType() != LEXEME_SEMICOLON)					{						Expression();						if (currentLexeme.GetType() != LEXEME_SEMICOLON)							throw ParserException();					}				}				GetLexeme();				if(currentLexeme.GetType() != LEXEME_RBRACKET)				{					Expression();					if(currentLexeme.GetType() != LEXEME_RBRACKET)						throw ParserException();				}				GetLexeme();				SingleOperator();			}			else				throw ParserException();			--isLoop;			break;		}		case LEXEME_BREAK:		{			GetLexeme();			if(currentLexeme.GetType() != LEXEME_SEMICOLON)				throw ParserException();			GetLexeme();			if(isLoop == 0)				throw ParserException();			break;		}		case LEXEME_GOTO:		{			GetLexeme();			if (currentLexeme.GetType() != LEXEME_NAME)				throw ParserException();			scanner.identTable[currentLexeme.GetValue()].ChangeType(LABEL);			scanner.identTable[currentLexeme.GetValue()].Declare();			GetLexeme();			if (currentLexeme.GetType() != LEXEME_SEMICOLON)				throw ParserException();			GetLexeme();			break;		}		case LEXEME_READ:		{			GetLexeme();			if (currentLexeme.GetType() != LEXEME_LBRACKET)				throw ParserException();			GetLexeme();			if (currentLexeme.GetType() != LEXEME_NAME)				throw ParserException();			if (!scanner.identTable[currentLexeme.GetValue()].IsDeclared())				throw ParserException();			GetLexeme();			if (currentLexeme.GetType() != LEXEME_RBRACKET)				throw ParserException();			GetLexeme();			if (currentLexeme.GetType() != LEXEME_SEMICOLON)				throw ParserException();			GetLexeme();			break;		}		case LEXEME_WRITE:		{			GetLexeme();			if (currentLexeme.GetType() != LEXEME_LBRACKET)				throw ParserException();			GetLexeme();			Expression();			while (currentLexeme.GetType() == LEXEME_COMMA)			{				GetLexeme();				Expression();			}			if (currentLexeme.GetType() != LEXEME_RBRACKET)				throw ParserException();			GetLexeme();			if (currentLexeme.GetType() != LEXEME_SEMICOLON)				throw ParserException();			GetLexeme();			break;		}		case LEXEME_LPARENTH: // compound operator		{			GetLexeme();			Operators();			if (currentLexeme.GetType() != LEXEME_RPARENTH)				throw ParserException();			GetLexeme();			break;		}		case LEXEME_NAME:		{			//auto lexValue = currentLexeme.GetValue();			auto type = scanner.identTable[currentLexeme.GetValue()].GetType();			if((type == INT) || (type == REAL) || (type == STRING)) // expression operator. in fact this is a define check.			{				Expression();				if (currentLexeme.GetType() != LEXEME_SEMICOLON)					throw ParserException();				GetLexeme(); // CHECK THIS			}			else //marked operator			{				scanner.identTable[currentLexeme.GetValue()].ChangeType(LABEL);				scanner.identTable[currentLexeme.GetValue()].Declare(); // ???				GetLexeme();				//if it was undefined there will be an exception				if(currentLexeme.GetType() != LEXEME_COLON)					throw ParserException();				GetLexeme();				SingleOperator();			}			break;		}		case LEXEME_NOT: case LEXEME_MINUS: case LEXEME_INT_CONST: case LEXEME_STRING_CONST: case LEXEME_REAL_CONST:		{			Expression();			if(currentLexeme.GetType() != LEXEME_SEMICOLON)				throw ParserException();			GetLexeme(); // CHECK THIS			break;		}		default:			throw ParserException();	}}void Parser::Expression(){	AssignmentExpression();	while (currentLexeme.GetType() == LEXEME_ASSIGNMENT)	{		lexemeStack.Push(LEXEME_ASSIGNMENT);		GetLexeme();		AssignmentExpression();		CheckOperands();	}}void Parser::AssignmentExpression(){	ArithmeticExpression();	while ((currentLexeme.GetType() == LEXEME_MORE) || (currentLexeme.GetType() == LEXEME_MORE_OR_EQUAL) || (currentLexeme.GetType() == LEXEME_LESS)		   || (currentLexeme.GetType() == LEXEME_LESS_OR_EQUAL) || (currentLexeme.GetType() == LEXEME_EQUAL) || (currentLexeme.GetType() == LEXEME_NOT_EQUAL))	{		lexemeStack.Push(currentLexeme.GetType());		GetLexeme();		ArithmeticExpression();		CheckOperands();	}}void Parser::ArithmeticExpression(){	Summand();	while((currentLexeme.GetType() == LEXEME_PLUS) || (currentLexeme.GetType() == LEXEME_MINUS) || (currentLexeme.GetType() == LEXEME_OR))	{		lexemeStack.Push(currentLexeme.GetType());		GetLexeme();		Summand();		CheckOperands();	}}void Parser::Summand(){	Factor();	while((currentLexeme.GetType() == LEXEME_MULTIPLY) || (currentLexeme.GetType() == LEXEME_DIVISION) || (currentLexeme.GetType() == LEXEME_AND))	{		lexemeStack.Push(currentLexeme.GetType());		GetLexeme();		Factor();		CheckOperands();	}}void Parser::Factor(){	if ((currentLexeme.GetType() == LEXEME_MINUS) || (currentLexeme.GetType() == LEXEME_NOT))	{		auto type = currentLexeme.GetType();		GetLexeme();		Factor();		// checking operand here????		if(type == LEXEME_NOT)			CheckNotOperand();		else			CheckUnaryMinusOperand();	}	else if (currentLexeme.GetType() == LEXEME_LBRACKET)	{		GetLexeme();		Expression();		if (currentLexeme.GetType() != LEXEME_RBRACKET)			throw ParserException();		GetLexeme();	}	else if (currentLexeme.GetType() == LEXEME_NAME)	{		//add Poliz and semantics !!!		if(!scanner.identTable[currentLexeme.GetValue()].IsDeclared())			throw ParserException();		if (scanner.identTable[currentLexeme.GetValue()].GetType() == USER)		{			auto structNumb = scanner.identTable[currentLexeme.GetValue()].GetIntValue(); // the number in struct vector			GetLexeme();			if (currentLexeme.GetType() == LEXEME_POINT)			{				GetLexeme();				//checking if the name is the structure member;				if (currentLexeme.GetType() != LEXEME_NAME)					throw ParserException();				String name = scanner.identTable[currentLexeme.GetValue()].GetName();				int position;				if ((position = structuresVector[structNumb].Search(name)) == -1)					throw ParserException();				/**********/				auto type = structuresVector[structNumb][position].GetType(); //some semantic trick				switch(type)				{					case INT:						lexemeStack.Push(LEXEME_INT);						break;					case STRING:						lexemeStack.Push(LEXEME_STRING);						break;					case REAL:						lexemeStack.Push(LEXEME_REAL);						break;					default:						throw ParserException();				}				/**********/			}			else				throw ParserException();		}		/*************/		auto type = scanner.identTable[currentLexeme.GetValue()].GetType(); //some semantic trick		switch(type)		{			case INT:				lexemeStack.Push(LEXEME_INT);				break;			case STRING:				lexemeStack.Push(LEXEME_STRING);				break;			case REAL:				lexemeStack.Push(LEXEME_REAL);				break;			case USER:				lexemeStack.Push(LEXEME_STRUCT);				break;			default:				throw ParserException();		}		/****************/		GetLexeme();	}	else if ((currentLexeme.GetType() == LEXEME_INT_CONST) || (currentLexeme.GetType() == LEXEME_STRING_CONST) ||			 (currentLexeme.GetType() == LEXEME_REAL_CONST))	{		/***********************/		auto type = currentLexeme.GetType();		switch(type)		{			case LEXEME_INT_CONST:				lexemeStack.Push(LEXEME_INT);				break;			case LEXEME_REAL_CONST:				lexemeStack.Push(LEXEME_REAL);				break;			case LEXEME_STRING_CONST:				lexemeStack.Push(LEXEME_STRING);				break;			default:				ParserException();		}		/***********************/		GetLexeme();	}	else	{		throw ParserException();	}}void Parser::StructureMemberDescription(){	auto type = currentLexeme.GetType();	int lastStructMemberNumber = 0;	GetLexeme();	if (currentLexeme.GetType() != LEXEME_NAME)		throw ParserException();	while(currentLexeme.GetType() == LEXEME_NAME)	{		structuresVector[lastStructureNumber].Push(scanner.identTable[currentLexeme.GetValue()]); // copying an identifier to the struct member table		switch(type)		{			case LEXEME_INT:			{				structuresVector[lastStructureNumber][lastStructMemberNumber].ChangeType(INT);				break;			}			case LEXEME_REAL:			{				structuresVector[lastStructureNumber][lastStructMemberNumber].ChangeType(REAL);				break;			}			case LEXEME_STRING:			{				structuresVector[lastStructureNumber][lastStructMemberNumber].ChangeType(STRING);				break;			}			default:				throw ParserException();		}		GetLexeme();		if (currentLexeme.GetType() == LEXEME_COMMA)			GetLexeme();		++lastStructMemberNumber;	}	if (currentLexeme.GetType() != LEXEME_SEMICOLON)		throw ParserException();}void Parser::CheckOperands(){	LexemeType firstOperand, secondOperand, oper, result;	secondOperand = lexemeStack.Pop();	oper = lexemeStack.Pop();	firstOperand = lexemeStack.Pop();	switch(oper)	{		case LEXEME_PLUS: case LEXEME_MINUS: case LEXEME_MULTIPLY: case LEXEME_DIVISION:		{			if(firstOperand == secondOperand)			{				if(((firstOperand == LEXEME_STRING) && (oper != LEXEME_PLUS)) || (firstOperand == LEXEME_STRUCT))					throw ParserException();				result = firstOperand;			}			else if( ((firstOperand == LEXEME_REAL) && (secondOperand == LEXEME_INT)) || ((secondOperand == LEXEME_REAL) && (firstOperand == LEXEME_INT)))				result = LEXEME_REAL;			else				throw ParserException();			break;		}		case LEXEME_MORE: case LEXEME_LESS: case LEXEME_MORE_OR_EQUAL: case LEXEME_LESS_OR_EQUAL: case LEXEME_NOT_EQUAL: case LEXEME_EQUAL:		{			if ( ((firstOperand == secondOperand) && (firstOperand != LEXEME_STRUCT)) ||				 (((firstOperand == LEXEME_INT) && (secondOperand == LEXEME_REAL)) || ((firstOperand == LEXEME_REAL) && (secondOperand == LEXEME_INT))))			{				result = LEXEME_INT;				// <= string??			}			else				throw ParserException();			break;		}		case LEXEME_AND: case LEXEME_OR:		{			if((firstOperand == secondOperand) && (firstOperand == LEXEME_INT))				result = LEXEME_INT;			else				throw ParserException();			break;		}		case LEXEME_ASSIGNMENT:		{			if((firstOperand == secondOperand)			   || (((firstOperand == LEXEME_REAL) && (secondOperand == LEXEME_INT)) || ((firstOperand == LEXEME_INT) && (secondOperand == LEXEME_REAL))))				result = firstOperand;			else				throw ParserException();			break;		}		default:			throw ParserException();	}	lexemeStack.Push(result);}void Parser::CheckNotOperand(){	if(lexemeStack.Pop() != LEXEME_INT)		throw ParserException();	lexemeStack.Push(LEXEME_INT);}void Parser::CheckUnaryMinusOperand(){	auto operand = lexemeStack.Pop();	if((operand != LEXEME_INT) && (operand != LEXEME_REAL))		throw ParserException();	lexemeStack.Push(operand);}