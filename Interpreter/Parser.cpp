#include "Parser.h"vector<Parser::Structure> Parser::structuresVector;void Parser::Analyze(){	structuresVector.push_back(Structure(nullptr)); //оставляем свободное место, которое займет таблица глобальных идентификаторов	++lastStructureNumber;	GetLexeme();	if(currentLexeme == LEXEME_PROGRAM)	{		GetLexeme();		Program();		if (currentLexeme != LEXEME_END)			throw ParserException();	}	else throw ParserException();}void Parser::Program(){	if (currentLexeme == LEXEME_LPARENTH)	{		GetLexeme();		Descriptions();		Operators();		if (currentLexeme != LEXEME_RPARENTH)			throw ParserException();		GetLexeme();	}	else		throw ParserException();}void Parser::Descriptions(){	while (currentLexeme == LEXEME_STRUCT)	{		StructDescription(); //currentLexeme == LEXEME_SEMICOLON ???	}	while ((currentLexeme == LEXEME_INT) || (currentLexeme == LEXEME_REAL) || (currentLexeme == LEXEME_STRING) || ((currentLexeme.GetType() == LEXEME_NAME) && (scanner.identTable[currentLexeme.GetValue()].GetType() == STRUCT_NAME)))	{		VariableDescription();	}	structuresVector[0] = Structure(scanner.identTable, nullptr);}void Parser::StructDescription(){	//currentlexeme == LEXEME_STRUCT	GetLexeme();	if (currentLexeme.GetType() == LEXEME_NAME)	{		scanner.identTable[currentLexeme.GetValue()].ChangeType(STRUCT_NAME);		if (scanner.identTable[currentLexeme.GetValue()].IsDeclared())			throw ParserException();		scanner.identTable[currentLexeme.GetValue()].Declare();		scanner.identTable[currentLexeme.GetValue()].ChangeIntValue(lastStructureNumber); // index of the structure in structuresVector		String name = scanner.identTable[currentLexeme.GetValue()].GetName();		structuresVector.push_back(Structure(name));		GetLexeme();		if (currentLexeme.GetType() != LEXEME_LPARENTH)			throw ParserException();		GetLexeme();		if ((currentLexeme.GetType() == LEXEME_INT) || (currentLexeme.GetType() == LEXEME_REAL) || (currentLexeme.GetType() == LEXEME_STRING))		{			StructureMemberDescription();		}		else			throw ParserException();		while((currentLexeme.GetType() == LEXEME_INT) || (currentLexeme.GetType() == LEXEME_REAL) || (currentLexeme.GetType() == LEXEME_STRING))		{			StructureMemberDescription();		}		if (currentLexeme.GetType() != LEXEME_RPARENTH)			throw ParserException();		GetLexeme();		if (currentLexeme.GetType() != LEXEME_SEMICOLON)			throw ParserException();		++lastStructureNumber;		GetLexeme();	}	else		throw ParserException();}void Parser::StructureMemberDescription(){	auto type = currentLexeme.GetType();	GetLexeme();	if (currentLexeme.GetType() != LEXEME_NAME)		throw ParserException();	while(currentLexeme.GetType() == LEXEME_NAME)	{		if (structuresVector[lastStructureNumber].Search(scanner.identTable[currentLexeme.GetValue()].GetName()) != -1)			throw ParserException(); // checking if already pushed		structuresVector[lastStructureNumber].Push(scanner.identTable[currentLexeme.GetValue()]);		auto lastStructureMemberNumber = structuresVector[lastStructureNumber].GetSize() - 1;		structuresVector[lastStructureNumber][lastStructureMemberNumber].Declare();		switch (type)		{			case LEXEME_INT:			{				structuresVector[lastStructureNumber][lastStructureMemberNumber].ChangeType(INT);				break;			}			case LEXEME_STRING:			{				structuresVector[lastStructureNumber][lastStructureMemberNumber].ChangeType(STRING);				break;			}			case LEXEME_REAL:			{				structuresVector[lastStructureNumber][lastStructureMemberNumber].ChangeType(REAL);				break;			}			default:				throw ParserException();		}		GetLexeme();		if (currentLexeme.GetType() == LEXEME_COMMA)			GetLexeme();		else if (currentLexeme.GetType() != LEXEME_SEMICOLON)			throw ParserException();	}	//currentLexeme == LEXEME_SEMICOLON	GetLexeme();}void Parser::VariableDescription(){	auto lexemeType = currentLexeme.GetType(); // saving current type of variable	auto structNameValue = currentLexeme.GetValue(); // saving current value for user types	GetLexeme();	if (currentLexeme.GetType() != LEXEME_NAME)		throw ParserException();	while ((currentLexeme.GetType() == LEXEME_NAME))	{		auto value = currentLexeme.GetValue();		if (scanner.identTable[value].IsDeclared())			throw ParserException();		scanner.identTable[value].Declare(); //making identifier declared		switch (lexemeType)		{			case LEXEME_INT:				scanner.identTable[value].ChangeType(INT);				break;			case LEXEME_REAL:				scanner.identTable[value].ChangeType(REAL);				break;			case LEXEME_STRING:				scanner.identTable[value].ChangeType(STRING);				break;			case LEXEME_NAME:			{				scanner.identTable[value].ChangeType(USER);				scanner.identTable[value].ChangeIntValue(lastStructureNumber);				structuresVector.push_back(structuresVector[structNameValue]);				++lastStructureNumber;				break;			}			default:				throw ParserException();		} //defining type		GetLexeme();				if (currentLexeme == LEXEME_ASSIGNMENT)		{			GetLexeme();			switch (lexemeType)			{				case LEXEME_INT:				{					bool unaryMinusFound = false;					if (currentLexeme == LEXEME_PLUS)						GetLexeme();					else if (currentLexeme == LEXEME_MINUS)					{						GetLexeme();						unaryMinusFound = true;					}					if (currentLexeme.GetType() != LEXEME_INT_CONST)						throw ParserException();					if(!unaryMinusFound)						scanner.identTable[value].ChangeIntValue(scanner.identTable[currentLexeme.GetValue()].GetIntValue());					else						scanner.identTable[value].ChangeIntValue(-scanner.identTable[currentLexeme.GetValue()].GetIntValue());					break;				}				case LEXEME_REAL:				{					bool unaryMinusFound = false;					if (currentLexeme == LEXEME_PLUS)						GetLexeme();					else if (currentLexeme == LEXEME_MINUS)					{						GetLexeme();						unaryMinusFound = true;					}					if (currentLexeme.GetType() != LEXEME_REAL_CONST)						throw ParserException();					if (!unaryMinusFound)						scanner.identTable[value].ChangeRealValue(scanner.identTable[currentLexeme.GetValue()].GetRealValue());					else						scanner.identTable[value].ChangeRealValue(-scanner.identTable[currentLexeme.GetValue()].GetRealValue());					break;				}				case LEXEME_STRING:				{					if (currentLexeme.GetType() != LEXEME_STRING_CONST)						throw ParserException();					scanner.identTable[value].ChangeStringValue(scanner.identTable[currentLexeme.GetValue()].GetStringValue());					break;				}				default:					throw ParserException();			}			GetLexeme();		}		// comma or semicolon after that		if (currentLexeme == LEXEME_COMMA)		{			GetLexeme();			if (currentLexeme.GetType() != LEXEME_NAME) // if there is no name after comma -> error				throw ParserException();		}	}	if (currentLexeme != LEXEME_SEMICOLON)		throw ParserException();	GetLexeme();}void Parser::Operators(){	while(currentLexeme != LEXEME_RPARENTH)	{		SingleOperator();	}}void Parser::SingleOperator(){	auto lexemeType = currentLexeme.GetType();	switch(lexemeType)	{		case LEXEME_IF:		{			GetLexeme();			if(currentLexeme.GetType() == LEXEME_LBRACKET)			{				GetLexeme();				Expression();				/************************************************/				// Reverse Polish notation actions				auto label1 = program.GetFreeElementNumber();				program.PutBlank();				program.AddLexeme(RPM_FALSE_GOTO);				/*********************************************/				//currentLexeme == RBRACKET				if (currentLexeme.GetType() != LEXEME_RBRACKET)					throw ParserException();				GetLexeme();				SingleOperator();				/***************************/				auto label2 = program.GetFreeElementNumber();				program.PutBlank();				program.AddLexeme(RPM_GOTO);				program.AddLexeme(Lexeme(RPM_LABEL, program.GetFreeElementNumber()), label1);				/********************************/				if (currentLexeme.GetType() == LEXEME_ELSE)				{					GetLexeme();					SingleOperator();				} // then the next operator came				/**********************/				program.AddLexeme(Lexeme(RPM_LABEL, program.GetFreeElementNumber()), label2);				/************/			}			else				throw ParserException();			break;		}		case LEXEME_WHILE:		{			++isLoop;			GetLexeme();			if(currentLexeme.GetType() == LEXEME_LBRACKET)			{				/***********************/				auto label1 = program.GetFreeElementNumber();				/**********************/				GetLexeme();				Expression();				/***********/				auto label2 = program.GetFreeElementNumber();				program.PutBlank();				program.AddLexeme(RPM_FALSE_GOTO);				/**********************/				if (currentLexeme.GetType() != LEXEME_RBRACKET)					throw ParserException();				GetLexeme();				SingleOperator();				/**********/				program.AddLexeme(Lexeme(RPM_LABEL, label1));				program.AddLexeme(RPM_GOTO);				program.AddLexeme(Lexeme(RPM_LABEL, program.GetFreeElementNumber()), label2);				/**********/			}			else throw ParserException();			--isLoop;			break;		}		case LEXEME_FOR:		{			GetLexeme();			++isLoop;			if(currentLexeme.GetType() == LEXEME_LBRACKET)			{				GetLexeme();				if (currentLexeme.GetType() != LEXEME_SEMICOLON)				{					Expression();					if (currentLexeme.GetType() != LEXEME_SEMICOLON)						throw ParserException();					program.AddLexeme(RPM_OUT_OF_STACK);				}				/********************/				auto label1 = program.GetFreeElementNumber();				/*******************/				GetLexeme();				if (currentLexeme.GetType() != LEXEME_SEMICOLON)				{					Expression();					if (currentLexeme.GetType() != LEXEME_SEMICOLON)						throw ParserException();					program.AddLexeme(RPM_OUT_OF_STACK);				}				/******************/				auto label2 = program.GetFreeElementNumber();				program.PutBlank();				program.AddLexeme(RPM_FALSE_GOTO);				auto label3 = program.GetFreeElementNumber();				program.PutBlank();				program.AddLexeme(RPM_GOTO);				auto label4 = program.GetFreeElementNumber();				/******************/				GetLexeme();				if(currentLexeme.GetType() != LEXEME_RBRACKET)				{					Expression();					if(currentLexeme.GetType() != LEXEME_RBRACKET)						throw ParserException();				}				/************/				program.AddLexeme(Lexeme(RPM_LABEL, label1));				program.AddLexeme(RPM_GOTO);				program.AddLexeme(Lexeme(RPM_LABEL, program.GetFreeElementNumber()), label3);				/************/				GetLexeme();				SingleOperator();				/***********************/				program.AddLexeme(Lexeme(RPM_LABEL, label4));				program.AddLexeme(RPM_GOTO);				program.AddLexeme(Lexeme(RPM_LABEL, program.GetFreeElementNumber()), label2);				/***********************/			}			else				throw ParserException();			--isLoop;			break;		}		case LEXEME_BREAK:		{			GetLexeme();			if(currentLexeme.GetType() != LEXEME_SEMICOLON)				throw ParserException();			GetLexeme();			if(isLoop == 0)				throw ParserException();			/*******************************************/			//ищем адрес по которому производится переход по лжи и сами ставим переход по такому адресу			auto position = program.SearchForFirstFalseGoto() - 1;			program.AddLexeme(Lexeme(RPM_LABEL, program[position].GetValue()));			program.AddLexeme(Lexeme(RPM_GOTO));			/*****************************************/			break;		}		case LEXEME_GOTO:		{			GetLexeme();			if (currentLexeme.GetType() != LEXEME_NAME)				throw ParserException();			if (!structuresVector[0][currentLexeme.GetValue()].IsDeclared())				throw ParserException();			program.AddLexeme(Lexeme(RPM_LABEL, structuresVector[0][currentLexeme.GetValue()].GetIntValue()));			program.AddLexeme(RPM_GOTO);			GetLexeme();			if (currentLexeme.GetType() != LEXEME_SEMICOLON)				throw ParserException();			GetLexeme();			break;		}		case LEXEME_READ:		{			GetLexeme();			if (currentLexeme.GetType() != LEXEME_LBRACKET)				throw ParserException();			GetLexeme();			if (currentLexeme.GetType() != LEXEME_NAME)				throw ParserException();			if (!structuresVector[0][currentLexeme.GetValue()].IsDeclared())				throw ParserException();			program.AddLexeme(Lexeme(RPM_ADDRESS, currentLexeme.GetValue(), currentLexeme.GetTableNumber()));			GetLexeme();			if (currentLexeme.GetType() != LEXEME_RBRACKET)				throw ParserException();			GetLexeme();			if (currentLexeme.GetType() != LEXEME_SEMICOLON)				throw ParserException();			GetLexeme();			program.AddLexeme(LEXEME_READ);			break;		}		case LEXEME_WRITE:		{			GetLexeme();			if (currentLexeme.GetType() != LEXEME_LBRACKET)				throw ParserException();			GetLexeme();			Expression();			while (currentLexeme.GetType() == LEXEME_COMMA)			{				GetLexeme();				Expression();			}			if (currentLexeme.GetType() != LEXEME_RBRACKET)				throw ParserException();			GetLexeme();			if (currentLexeme.GetType() != LEXEME_SEMICOLON)				throw ParserException();			GetLexeme();			program.AddLexeme(LEXEME_WRITE);			break;		}		case LEXEME_LPARENTH: // compound operator		{			GetLexeme();			Operators();			if (currentLexeme.GetType() != LEXEME_RPARENTH)				throw ParserException();			GetLexeme();			break;		}		case LEXEME_NAME:		{			//auto lexValue = currentLexeme.GetValue();			auto type = structuresVector[0][currentLexeme.GetValue()].GetType();			if((type == INT) || (type == REAL) || (type == STRING) || (type == USER)) // expression operator. in fact this is a define check.			{				if (type != USER)				{					program.AddLexeme(Lexeme(RPM_ADDRESS, currentLexeme.GetValue()));					GetLexeme();					if (currentLexeme.GetType() != LEXEME_ASSIGNMENT)						throw ParserException();					GetLexeme();					Expression();					if (currentLexeme.GetType() != LEXEME_SEMICOLON)						throw ParserException();					program.AddLexeme(LEXEME_ASSIGNMENT);					program.AddLexeme(RPM_OUT_OF_STACK);					GetLexeme(); // CHECK THIS				}				else				{					auto value = currentLexeme.GetValue(); //saving value of object name					GetLexeme();					if (currentLexeme.GetType() == LEXEME_POINT)					{						GetLexeme();						if (currentLexeme.GetType() != LEXEME_NAME)							throw ParserException();						auto structIndex = structuresVector[0][value].GetIntValue();						int position;						if((position = structuresVector[structIndex].Search(structuresVector[0][currentLexeme.GetValue()].GetName())) != -1)						{							GetLexeme();							if (currentLexeme.GetType() != LEXEME_ASSIGNMENT)								throw ParserException();							program.AddLexeme(Lexeme(RPM_ADDRESS, position, structIndex));							GetLexeme();							Expression();							if (currentLexeme.GetType() != LEXEME_SEMICOLON)								throw ParserException();							program.AddLexeme(LEXEME_ASSIGNMENT);							program.AddLexeme(RPM_OUT_OF_STACK);							GetLexeme();						}						else throw ParserException();					}					else					{						// Structure assignement						program.AddLexeme(Lexeme(RPM_ADDRESS, value));						if (currentLexeme.GetType() != LEXEME_ASSIGNMENT)							throw ParserException();						GetLexeme();						if ((currentLexeme.GetType() != LEXEME_NAME) || (structuresVector[0][currentLexeme.GetValue()].GetType() != USER))							throw ParserException();						//if the type is equal						if (structuresVector[structuresVector[0][value].GetIntValue()].GetTypeName() != structuresVector[structuresVector[0][currentLexeme.GetValue()].GetIntValue()].GetTypeName())							throw ParserException();						program.AddLexeme(Lexeme(LEXEME_NAME, currentLexeme.GetValue()));						GetLexeme();						if (currentLexeme.GetType() != LEXEME_SEMICOLON)							throw ParserException();						program.AddLexeme(LEXEME_ASSIGNMENT);						program.AddLexeme(RPM_OUT_OF_STACK);						GetLexeme(); 					}				}			}			else //marked operator			{				structuresVector[0][currentLexeme.GetValue()].ChangeType(LABEL);				if (structuresVector[0][currentLexeme.GetValue()].IsDeclared())					throw ParserException();				structuresVector[0][currentLexeme.GetValue()].Declare(); // ???				structuresVector[0][currentLexeme.GetValue()].ChangeIntValue(program.GetFreeElementNumber());				GetLexeme();				//if it was undefined there will be an exception				if(currentLexeme.GetType() != LEXEME_COLON)					throw ParserException();				GetLexeme();				SingleOperator();			}			break;		}		case LEXEME_NOT: case LEXEME_MINUS: case LEXEME_INT_CONST: case LEXEME_STRING_CONST: case LEXEME_REAL_CONST:		{			Expression();			if(currentLexeme.GetType() != LEXEME_SEMICOLON)				throw ParserException();			program.AddLexeme(RPM_OUT_OF_STACK);			GetLexeme(); // CHECK THIS			break;		}		default:			throw ParserException();	}}void Parser::Expression(){	AssignmentExpression();}void Parser::AssignmentExpression(){	ArithmeticExpression();	while ((currentLexeme.GetType() == LEXEME_MORE) || (currentLexeme.GetType() == LEXEME_MORE_OR_EQUAL) || (currentLexeme.GetType() == LEXEME_LESS)		   || (currentLexeme.GetType() == LEXEME_LESS_OR_EQUAL) || (currentLexeme.GetType() == LEXEME_EQUAL) || (currentLexeme.GetType() == LEXEME_NOT_EQUAL))	{		lexemeStack.Push(currentLexeme.GetType());		GetLexeme();		ArithmeticExpression();		CheckOperands();	}}void Parser::ArithmeticExpression(){	Summand();	while((currentLexeme.GetType() == LEXEME_PLUS) || (currentLexeme.GetType() == LEXEME_MINUS) || (currentLexeme.GetType() == LEXEME_OR))	{		lexemeStack.Push(currentLexeme.GetType());		GetLexeme();		Summand();		CheckOperands();	}}void Parser::Summand(){	Factor();	while((currentLexeme.GetType() == LEXEME_MULTIPLY) || (currentLexeme.GetType() == LEXEME_DIVISION) || (currentLexeme.GetType() == LEXEME_AND))	{		lexemeStack.Push(currentLexeme.GetType());		GetLexeme();		Factor();		CheckOperands();	}}void Parser::Factor(){	if ((currentLexeme.GetType() == LEXEME_MINUS) || (currentLexeme.GetType() == LEXEME_NOT))	{		auto type = currentLexeme.GetType();		GetLexeme();		Factor();		// checking operand here????		if (type == LEXEME_NOT)		{			CheckNotOperand();			program.AddLexeme(LEXEME_NOT);		}		else		{			CheckUnaryMinusOperand();			program.AddLexeme(LEXEME_UNARY_MINUS);		}	}	else if (currentLexeme.GetType() == LEXEME_LBRACKET)	{		GetLexeme();		Expression();		if (currentLexeme.GetType() != LEXEME_RBRACKET)			throw ParserException();		GetLexeme();	}	else if (currentLexeme.GetType() == LEXEME_NAME)	{		if(!structuresVector[0][currentLexeme.GetValue()].IsDeclared())			throw ParserException();		if (structuresVector[0][currentLexeme.GetValue()].GetType() == USER) // structure handling		{			auto structIndex = structuresVector[0][currentLexeme.GetValue()].GetIntValue();			GetLexeme();			if(currentLexeme.GetType() == LEXEME_POINT)			{				//member access				GetLexeme();				if (currentLexeme.GetType() != LEXEME_NAME)					throw ParserException();				int position;				if((position = structuresVector[structIndex].Search(structuresVector[0][currentLexeme.GetValue()].GetName())) != -1)				{										auto type = structuresVector[structIndex][position].GetType();					switch(type)					{						case INT:						{							lexemeStack.Push(LEXEME_INT);							break;						}						case REAL:						{							lexemeStack.Push(LEXEME_REAL);							break;						}						case STRING:						{							lexemeStack.Push(LEXEME_REAL);							break;						}						default:							throw ParserException();					}					program.AddLexeme(Lexeme(LEXEME_NAME, position, structIndex));				}				else throw ParserException();				GetLexeme();			}			else			{				//structure assignment, but it should be handled before				throw ParserException();			}		}		else		{			/*************/			auto type = structuresVector[0][currentLexeme.GetValue()].GetType(); //some semantic trick			switch (type)			{				case INT:					lexemeStack.Push(LEXEME_INT);					break;				case STRING:					lexemeStack.Push(LEXEME_STRING);					break;				case REAL:					lexemeStack.Push(LEXEME_REAL);					break;				default:					throw ParserException();			}			/****************/			program.AddLexeme(currentLexeme);			GetLexeme();		}	}	else if ((currentLexeme.GetType() == LEXEME_INT_CONST) || (currentLexeme.GetType() == LEXEME_STRING_CONST) ||			 (currentLexeme.GetType() == LEXEME_REAL_CONST))	{		/***********************/		auto type = currentLexeme.GetType();		switch(type)		{			case LEXEME_INT_CONST:				lexemeStack.Push(LEXEME_INT);				break;			case LEXEME_REAL_CONST:				lexemeStack.Push(LEXEME_REAL);				break;			case LEXEME_STRING_CONST:				lexemeStack.Push(LEXEME_STRING);				break;			default:				ParserException();		}		/***********************/		program.AddLexeme(currentLexeme);		GetLexeme();	}	else	{		throw ParserException();	}}void Parser::CheckOperands(){	LexemeType firstOperand, secondOperand, oper, result;	secondOperand = lexemeStack.Pop();	oper = lexemeStack.Pop();	firstOperand = lexemeStack.Pop();	switch(oper)	{		case LEXEME_PLUS: case LEXEME_MINUS: case LEXEME_MULTIPLY: case LEXEME_DIVISION:		{			if(firstOperand == secondOperand)			{				if(((firstOperand == LEXEME_STRING) && (oper != LEXEME_PLUS)) || (firstOperand == LEXEME_STRUCT))					throw ParserException();				result = firstOperand;			}			else if( ((firstOperand == LEXEME_REAL) && (secondOperand == LEXEME_INT)) || ((secondOperand == LEXEME_REAL) && (firstOperand == LEXEME_INT)))				result = LEXEME_REAL;			else				throw ParserException();			break;		}		case LEXEME_MORE: case LEXEME_LESS: case LEXEME_MORE_OR_EQUAL: case LEXEME_LESS_OR_EQUAL: case LEXEME_NOT_EQUAL: case LEXEME_EQUAL:		{			if ( ((firstOperand == secondOperand) && (firstOperand != LEXEME_STRUCT)) ||				 (((firstOperand == LEXEME_INT) && (secondOperand == LEXEME_REAL)) || ((firstOperand == LEXEME_REAL) && (secondOperand == LEXEME_INT))))			{				result = LEXEME_INT;				// <= string??			}			else				throw ParserException();			break;		}		case LEXEME_AND: case LEXEME_OR:		{			if((firstOperand == secondOperand) && (firstOperand == LEXEME_INT))				result = LEXEME_INT;			else				throw ParserException();			break;		}		case LEXEME_ASSIGNMENT:		{			if((firstOperand == secondOperand)			   || (((firstOperand == LEXEME_REAL) && (secondOperand == LEXEME_INT)) || ((firstOperand == LEXEME_INT) && (secondOperand == LEXEME_REAL))))				result = firstOperand;			else				throw ParserException();			break;		}		default:			throw ParserException();	}	lexemeStack.Push(result);	/**********/	program.AddLexeme(oper);	/*********/}void Parser::CheckNotOperand(){	if(lexemeStack.Pop() != LEXEME_INT)		throw ParserException();	lexemeStack.Push(LEXEME_INT);}void Parser::CheckUnaryMinusOperand(){	auto operand = lexemeStack.Pop();	if((operand != LEXEME_INT) && (operand != LEXEME_REAL))		throw ParserException();	lexemeStack.Push(operand);}