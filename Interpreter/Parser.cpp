#include "Parser.h"void Parser::Analyze(){	GetLexeme();	if(currentLexeme == LEXEME_PROGRAM)	{		GetLexeme();		Program();		if (currentLexeme != LEXEME_END)			throw ParserException();	}	else throw ParserException();}void Parser::Program(){	if (currentLexeme == LEXEME_LPARENTH)	{		GetLexeme();		Descriptions();		Operators();		if (currentLexeme != LEXEME_RPARENTH)			throw ParserException();		GetLexeme();	}	else		throw ParserException();}void Parser::Descriptions(){	while (currentLexeme == LEXEME_STRUCT)	{		StructDescription(); //currentLexeme == LEXEME_SEMICOLON ???	}	while ((currentLexeme == LEXEME_INT) || (currentLexeme == LEXEME_REAL) || (currentLexeme == LEXEME_STRING) || ((currentLexeme.GetType() == LEXEME_NAME) && (scanner.identTable[currentLexeme.GetValue()].GetType() == STRUCT_NAME)))	{		VariableDescription();	}}void Parser::StructDescription(){	/* В таблице лексем значение лексемы-имени структуры - номер в таблице всех имен		В таблице всех имен значение имени - номер в таблице структур, которая представляет собой вектор таблиц идентификаторов		Каждое имя члена структуры вносится в соотетсвующую таблицу идентификаторов	*/	//currentLexeme == LEXEME_STRUCT	GetLexeme();	if (currentLexeme.GetType() == LEXEME_NAME)	{		scanner.identTable[currentLexeme.GetValue()].ChangeType(STRUCT_NAME);		scanner.identTable[currentLexeme.GetValue()].ChangeIntValue(lastStructureNumber);		structuresVector.push_back(IdentTable());		//std::vector<IdentTable>::iterator it = --structures.end(); // iterator pointing at the last structure		GetLexeme();		if(currentLexeme == LEXEME_LPARENTH)		{			GetLexeme();			if ((currentLexeme == LEXEME_INT) || (currentLexeme == LEXEME_REAL) || (currentLexeme == LEXEME_STRING))			{				StructureMemberDescription(); //??				GetLexeme();			}			else				throw ParserException();			while ((currentLexeme == LEXEME_INT) || (currentLexeme == LEXEME_REAL) || (currentLexeme == LEXEME_STRING))			{				StructureMemberDescription(); // ??				GetLexeme();			}			if(currentLexeme == LEXEME_RPARENTH)			{				GetLexeme();				if (currentLexeme == LEXEME_SEMICOLON)					GetLexeme();				else					throw ParserException();			}			else throw ParserException();		}		++lastStructureNumber;	}	else		throw ParserException();}void Parser::VariableDescription(){	auto lexemeType = currentLexeme.GetType(); // saving current type of variable	GetLexeme();	if (currentLexeme.GetType() != LEXEME_NAME)		throw ParserException();	while ((currentLexeme.GetType() == LEXEME_NAME))	{		auto value = currentLexeme.GetValue();		if (scanner.identTable[value].isDeclared())			throw ParserException();		scanner.identTable[value].Declare(); //making identifier declared		switch (lexemeType)		{			case LEXEME_INT:				scanner.identTable[value].ChangeType(INT);				break;			case LEXEME_REAL:				scanner.identTable[value].ChangeType(REAL);				break;			case LEXEME_STRING:				scanner.identTable[value].ChangeType(STRING);				break;			case LEXEME_NAME:				scanner.identTable[value].ChangeType(USER);				break;			default:				throw ParserException();		} //defining type		GetLexeme();				if (currentLexeme == LEXEME_ASSIGNMENT)		{			GetLexeme();			switch (lexemeType)			{				case LEXEME_INT:				{					bool unaryMinusFound = false;					if (currentLexeme == LEXEME_PLUS)						GetLexeme();					else if (currentLexeme == LEXEME_MINUS)					{						GetLexeme();						unaryMinusFound = true;					}					if (currentLexeme.GetType() != LEXEME_INT_CONST)						throw ParserException();					if(!unaryMinusFound)						scanner.identTable[value].ChangeIntValue(scanner.identTable[currentLexeme.GetValue()].GetIntValue());					else						scanner.identTable[value].ChangeIntValue(-scanner.identTable[currentLexeme.GetValue()].GetIntValue());					break;				}				case LEXEME_REAL:				{					bool unaryMinusFound = false;					if (currentLexeme == LEXEME_PLUS)						GetLexeme();					else if (currentLexeme == LEXEME_MINUS)					{						GetLexeme();						unaryMinusFound = true;					}					if (currentLexeme.GetType() != LEXEME_REAL_CONST)						throw ParserException();					if (!unaryMinusFound)						scanner.identTable[value].ChangeRealValue(scanner.identTable[currentLexeme.GetValue()].GetRealValue());					else						scanner.identTable[value].ChangeRealValue(-scanner.identTable[currentLexeme.GetValue()].GetRealValue());					break;				}				case LEXEME_STRING:				{					if (currentLexeme.GetType() != LEXEME_STRING_CONST)						throw ParserException();					scanner.identTable[value].ChangeStringValue(scanner.identTable[currentLexeme.GetValue()].GetStringValue());					break;				}				default:					throw ParserException();			}			GetLexeme();		}		// comma or semicolon after that		if (currentLexeme == LEXEME_COMMA)		{			GetLexeme();			if (currentLexeme.GetType() != LEXEME_NAME) // if there is no name after comma -> error				throw ParserException();		}	}	if (currentLexeme != LEXEME_SEMICOLON)		throw ParserException();	GetLexeme();}void Parser::Operators(){	while(currentLexeme != LEXEME_RPARENTH)	{		SingleOperator();	}}void Parser::SingleOperator(){	auto lexemeType = currentLexeme.GetType();	switch(lexemeType)	{		case LEXEME_IF:		{			GetLexeme();			if(currentLexeme.GetType() == LEXEME_LBRACKET)			{				GetLexeme();				Expression();				//currentLexeme == RBRACKET				if (currentLexeme.GetType() != LEXEME_RBRACKET)					throw ParserException();				GetLexeme();				SingleOperator();				if (currentLexeme.GetType() != LEXEME_ELSE)					throw ParserException();				GetLexeme();				SingleOperator();			}			else throw ParserException();			break;		}		case LEXEME_WHILE:		{			++isLoop;			GetLexeme();			if(currentLexeme.GetType() == LEXEME_LBRACKET)			{				GetLexeme();				Expression();				if (currentLexeme.GetType() != LEXEME_RBRACKET)					throw ParserException();				GetLexeme();				SingleOperator();			}			else throw ParserException();			--isLoop;			break;		}		case LEXEME_FOR:		{			GetLexeme();			++isLoop;			if(currentLexeme.GetType() == LEXEME_LBRACKET)			{				for(int i = 0; i < 2; ++i)				{					GetLexeme();					if (currentLexeme.GetType() != LEXEME_SEMICOLON)					{						Expression();						if (currentLexeme.GetType() != LEXEME_SEMICOLON)							throw ParserException();					}				}				GetLexeme();				if(currentLexeme.GetType() != LEXEME_RBRACKET)				{					Expression();					if(currentLexeme.GetType() != LEXEME_RBRACKET)						throw ParserException();				}				GetLexeme();				SingleOperator();			}			else				throw ParserException();			--isLoop;			break;		}		case LEXEME_BREAK:		{			GetLexeme();			if(currentLexeme.GetType() != LEXEME_SEMICOLON)				throw ParserException();			GetLexeme();			if(isLoop == 0)				throw ParserException();			break;		}		case LEXEME_GOTO:		{			GetLexeme();			if (currentLexeme.GetType() != LEXEME_NAME)				throw ParserException();			scanner.identTable[currentLexeme.GetValue()].ChangeType(LABEL);			GetLexeme();			if (currentLexeme.GetType() != LEXEME_SEMICOLON)				throw ParserException();			GetLexeme();			break;		}		case LEXEME_READ:		{			GetLexeme();			if (currentLexeme.GetType() != LEXEME_LBRACKET)				throw ParserException();			GetLexeme();			if (currentLexeme.GetType() != LEXEME_NAME)				throw ParserException();			if (!scanner.identTable[currentLexeme.GetValue()].isDeclared())				throw ParserException();			GetLexeme();			if (currentLexeme.GetType() != LEXEME_RBRACKET)				throw ParserException();			GetLexeme();			if (currentLexeme.GetType() != LEXEME_SEMICOLON)				throw ParserException();			GetLexeme();			break;		}		case LEXEME_WRITE:		{			GetLexeme();			if (currentLexeme.GetType() != LEXEME_LBRACKET)				throw ParserException();			GetLexeme();			Expression();			while (currentLexeme.GetType() == LEXEME_COMMA)			{				GetLexeme();				Expression();			}			if (currentLexeme.GetType() != LEXEME_RBRACKET)				throw ParserException();			GetLexeme();			if (currentLexeme.GetType() != LEXEME_SEMICOLON)				throw ParserException();			GetLexeme();			break;		}		case LEXEME_LPARENTH: // compound operator		{			GetLexeme();			Operators();			if (currentLexeme.GetType() != LEXEME_RPARENTH)				throw ParserException();			GetLexeme();			break;		}		case LEXEME_NAME:		{			//auto lexValue = currentLexeme.GetValue();			auto type = scanner.identTable[currentLexeme.GetValue()].GetType();			if((type == INT) || (type == REAL) || (type == STRING)) // expression operator			{				Expression();				if (currentLexeme.GetType() != LEXEME_SEMICOLON)					throw ParserException();				GetLexeme(); // CHECK THIS			}			else //marked operator			{				scanner.identTable[currentLexeme.GetValue()].ChangeType(LABEL);				GetLexeme();				if(currentLexeme.GetType() != LEXEME_COLON)					throw ParserException();				GetLexeme();				SingleOperator();			}			break;		}		case LEXEME_NOT: case LEXEME_MINUS: case LEXEME_INT_CONST: case LEXEME_STRING_CONST: case LEXEME_REAL_CONST:		{			Expression();			if(currentLexeme.GetType() != LEXEME_SEMICOLON)				throw ParserException();			GetLexeme(); // CHECK THIS			break;		}		default:			throw ParserException();	}}void Parser::Expression(){	AssignmentExpression();	while (currentLexeme.GetType() == LEXEME_ASSIGNMENT)	{		GetLexeme();		AssignmentExpression();	}}void Parser::AssignmentExpression(){	ArithmeticExpression();	while ((currentLexeme.GetType() == LEXEME_MORE) || (currentLexeme.GetType() == LEXEME_MORE_OR_EQUAL) || (currentLexeme.GetType() == LEXEME_LESS)		   || (currentLexeme.GetType() == LEXEME_LESS_OR_EQUAL) || (currentLexeme.GetType() == LEXEME_EQUAL) || (currentLexeme.GetType() == LEXEME_NOT_EQUAL))	{		GetLexeme();		ArithmeticExpression();	}}void Parser::ArithmeticExpression(){	Summand();	while((currentLexeme.GetType() == LEXEME_PLUS) || (currentLexeme.GetType() == LEXEME_MINUS) || (currentLexeme.GetType() == LEXEME_OR))	{		GetLexeme();		Summand();	}}void Parser::Summand(){	Factor();	while((currentLexeme.GetType() == LEXEME_MULTIPLY) || (currentLexeme.GetType() == LEXEME_DIVISION) || (currentLexeme.GetType() == LEXEME_AND))	{		GetLexeme();		Factor();	}}void Parser::Factor(){	auto type = currentLexeme.GetType();	if ((currentLexeme.GetType() == LEXEME_MINUS) || (currentLexeme.GetType() == LEXEME_NOT))	{		GetLexeme();		Factor();	}	else if (currentLexeme.GetType() == LEXEME_LBRACKET)	{		GetLexeme();		Expression();		if (currentLexeme.GetType() != LEXEME_RBRACKET)			throw ParserException();		GetLexeme();	}	else if (currentLexeme.GetType() == LEXEME_NAME)	{		//add Poliz and semantics !!!		if (scanner.identTable[currentLexeme.GetValue()].GetType() == USER)		{			auto structNumb = scanner.identTable[currentLexeme.GetValue()].GetIntValue(); // the number in struct vector			GetLexeme();			if (currentLexeme.GetType() == LEXEME_POINT)			{				GetLexeme();				//checking if the name is the structure member;				if (currentLexeme.GetType() != LEXEME_NAME)					throw ParserException();				String name = scanner.identTable[currentLexeme.GetValue()].GetName();				if (structuresVector[structNumb].Search(name) == -1)					throw ParserException();			}			else				throw ParserException();		}		GetLexeme();	}	else if ((currentLexeme.GetType() == LEXEME_INT_CONST) || (currentLexeme.GetType() == LEXEME_STRING_CONST) ||			 (currentLexeme.GetType() == LEXEME_REAL_CONST))		GetLexeme();	else	{		throw ParserException();	}}void Parser::StructureMemberDescription(){	auto type = currentLexeme.GetType();	int lastStructMemberNumber = 0;	GetLexeme();	if (currentLexeme.GetType() != LEXEME_NAME)		throw ParserException();	while(currentLexeme.GetType() == LEXEME_NAME)	{		structuresVector[lastStructureNumber].Push(scanner.identTable[currentLexeme.GetValue()]); // copying an identifier to the struct member table		switch(type)		{			case LEXEME_INT:			{				structuresVector[lastStructureNumber][lastStructMemberNumber].ChangeType(INT);				break;			}			case LEXEME_REAL:			{				structuresVector[lastStructureNumber][lastStructMemberNumber].ChangeType(REAL);				break;			}			case LEXEME_STRING:			{				structuresVector[lastStructureNumber][lastStructMemberNumber].ChangeType(STRING);				break;			}			default:				throw ParserException();		}		GetLexeme();		if (currentLexeme.GetType() == LEXEME_COMMA)			GetLexeme();		++lastStructMemberNumber;	}	if (currentLexeme.GetType() != LEXEME_SEMICOLON)		throw ParserException();}